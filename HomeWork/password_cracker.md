# Password Cracker

암호를 알아낼 수 있는 특수한 배열이 있습니다. 배열 내의 이진수 값들을 이용하여 암호를 알아낼 수 있는데, 암호는 __A부터 N__ 까지, 14개의 11비트 정수를 이용해 표현됩니다. 하지만 모두 사용되지는 않고, 그 중 8개만 사용됩니다. 오늘의 경우는 ![](https://latex.codecogs.com/gif.latex?A%20&plus;%20B%20&plus;%20C%20&plus;%20D%20-%20E%20-%20F%20-%20G%20-%20H)가 암호입니다. 

배열이 주어졌을 때, 오늘의 암호를 찾는 것이 문제입니다.

2차원 배열을 1차원으로 길게 늘어트린다고 생각했을 때, 값 A부터 N은 배열의 처음부터 11비트씩 끊어서 만들어집니다. 예를 들면, A는 맨 처음 11비트, B는 그 다음 11비트, C는 그 다음 11비트… 와 같은 방식으로 얻어낼 수 있습니다. 우리의 목표는 주어진 배열에서 A, B, C, D, E, F, G, H의 값을 찾아내는 것입니다.
주어지는 배열은 다음과 같습니다.

```Not
00000000
00100000
00000110
11111111
01000000
00010000
00000010
00000000
01000000
00001000
00000001
00000000
00100000
00000100
00000000
10000000
00010000
00000010
00000000
01000000
```

단, 조건 사항이 있습니다. 암호를 찾는 과정은 모두 비트단위 연산이나 비트 시프트 연산으로 이루어져야 합니다. 반복문 또는 조건문의 사용은 일체 금지입니다.


##### 배열

```c
unsigned char bits[20][8] = {
	{0, 0, 0, 0, 0, 0, 0, 0},
    {0, 0, 1, 0, 0, 0, 0, 0},
	{0, 0, 0, 0, 0, 1, 1, 0},
	{1, 1, 1, 1, 1, 1, 1, 1},
	{0, 1, 0, 0, 0, 0, 0, 0},
	{0, 0, 0, 1, 0, 0, 0, 0},
	{0, 0, 0, 0, 0, 0, 1, 0},
	{0, 0, 0, 0, 0, 0, 0, 0},
	{0, 1, 0, 0, 0, 0, 0, 0},
	{0, 0, 0, 0, 1, 0, 0, 0},
	{0, 0, 0, 0, 0, 0, 0, 1},
	{0, 0, 0, 0, 0, 0, 0, 0},
	{0, 0, 1, 0, 0, 0, 0, 0},
	{0, 0, 0, 0, 0, 1, 0, 0},
	{0, 0, 0, 0, 0, 0, 0, 0},
	{1, 0, 0, 0, 0, 0, 0, 0},
	{0, 0, 0, 1, 0, 0, 0, 0},
	{0, 0, 0, 0, 0, 0, 1, 0},
	{0, 0, 0, 0, 0, 0, 0, 0},
	{0, 1, 0, 0, 0, 0, 0, 0}
 }
```

