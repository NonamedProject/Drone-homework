# UBlox M8 GPS

 ###  GPS(Global Positioning System)

 위성에서 보내는 신호를 수신해 사용자의 현재 위치를 알려주는 시스템

### 원리
 GPS위성 안에는 세슘이라는 물질을 품은 정밀한 원자시계가 들어 있다. 이 시계는 십만 년 동안 1초 정도의 오차를 갖을정도로 매우 정밀하다.

GPS 위성은 이 시계의 정확한 시각과 위성의 정확한 위치를 지상의 수신기로 보낸다. 그러나 전파가 오는 데 시간이 걸리니 위성에서 보낸 시간과 수신기가 받는 시간에는 차이가 생긴다. 이때 둘의 차이에 빛의 속도를 곱해주면 지상 수신기에서 인공위성까지의 거리를 구할 수 있다. (거리=시간 X 속도)

이와 같은 작업을 3개의 인공위성이 동시에 수행하면 공간 상의 한 점을 찾을 수 있다. 경도, 위도와 높이를 동시에 파악하기 위해서는 3개의 위성신호가 필요하며, 위성간 시간 오차를 제거하기 위한 신호용 위성이 필요하기 때문에 4개의 위성이 사용된다. 즉, 정확한 위치를 계산하기위해서는 4개의 위성이 필요하다. 



## POSLLH 메세지(Geodetic Position Solution)

 이 메시지는 현재 선택된 타원체에서 측지 위치를 출력한다. 기본값은 WGS84 타원체이지만 CFG-DAT 메시지로 변경할 수 있다.

 ### 패킷 구조

|  Header   | class |  ID  | Length(Bytes) |  Payload  | Checksum  |
| :-------: | :---: | :--: | :-----------: | :-------: | --------- |
| 0xB5 0x65 | 0x01  | 0x02 |      28       | see below | CK_A CK_B |



### 데이터 종류

| Byte Offset | 숫자 구성방식 | 표시 형식 |  이름  | 단위 |         내용          |
| :---------: | :-----------: | :-------: | :----: | :--: | :-------------------: |
|      0      |      U4       |     -     |  iTOW  |  ms  |       GPS 시간        |
|      4      |      I4       |   1e-7    |  lon   | deg  |         경도          |
|      8      |      I4       |   le-7    |  lat   | deg  |         위도          |
|     12      |      I4       |     -     | height |  mm  |   타원체 위의 높이    |
|     16      |      I4       |     -     |  hMSL  |  mm  | 평균 해수면 위의 높이 |
|     20      |      U4       |     -     |  hAcc  |  mm  |  수평 정확도 추정치   |
|     24      |      U4       |     -     |  vAcc  |  mm  |  수직 정확도 추정치   |



# Endian

  컴퓨터의 메모리와 같은 1차원의 공간에 여러 개의 연속된 대상을 배열하는 방법을 뜻한다. 바이트를 배열하는 방법을 특히 바이트 순서(Byte order)라 한다.

데이터를 메모리에 저장하는 방법은 보통 2가지로 나눌 수 있다.

1. 빅 엔디안

   * 최상위 바이트부터 차례로 저장하는 방식이다.

   * 사람이 숫자를 쓰는 방법과 같이 큰 단위의 바이트가 앞에 온다.

   * 앞에서 부터 PUSH한다.

     * 0x12345678의 표현

       **00010010**|**00110100**|**01010110**|**01111000**

       ​      12                  34               56               78

   * 장점

     1. 사람이 숫자를 읽고 쓰는 방법과 같기 때문에 디버깅 과정에서 메모리의 값을 보기 편하다.

     2. 두 개의 숫자를 비교 할 때 더욱 빠르게 비교할 수 있다.  첫 바이트에서 한쪽이 더 크다면 나머지 바이트들은 더 이상 비교를 할 필요가 없기 때문이다 

1. 리틀 엔디안

   * 최하위 바이트부터 차례로 저장하는 방식이다.

   * 빅 엔디안과 반대로 작은 단위의 바이트가 앞에 온다.

   * 뒤에서 부터 스택에 PUSH한다.

     * 0x12345678의 표현

       **01111000**|**01010110**|**00110100**|**00010010**

       ​	78		   56                34                12


   * 장점

     1.  짝수인지 홀수인지를 검사할 때 빠르다. 첫 바이트 하나만 보면 짝수인지 홀수인지를 금방 알 수 있기 때문이다

     2. 계산 연산에서 빅 엔디안보다 속도가 빠르다.
     3.  Little Endian 방식은 포인터(pointer)의 값 참조 시 유리하다.

데이터 전송을 할 때 엔디안 방식의 차이에 주의해야 한다. 서로 다른 데이터 저장 방식의 시스템끼리 통신하게 되면 전혀 엉뚱한 값을 주고 받기 때문이다. 그러므로 메모리 분석을 정확하게 하기위해선 ,이 Big Endian과 Little Endian을 잘 알고 있어야 한다.

----

**참고자료**

[Endian](https://www.youtube.com/watch?v=qGN4LBomxFQ)

[Endian](https://ko.wikipedia.org/wiki/%EC%97%94%EB%94%94%EC%96%B8)

[GPS](http://blog.lgdisplay.com/2016/06/gps/)

[GPS](http://ktechno.co.kr/techgisa/gps9908/gps02.html)

***

